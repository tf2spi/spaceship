.MEMORYMAP
SLOTSIZE $4000
DEFAULTSLOT 0
SLOT 0 $0000
SLOT 1 $4000
SLOT 2 $8000 SIZE $2000 "VRAM"
SLOT 3 $C000 SIZE $1000 "WRAM"
SLOT 4 $FF80 SIZE $80 "HRAM"
.ENDME

.ROMBANKMAP
BANKSTOTAL 2
BANKSIZE $4000
BANKS 2
.ENDRO

.STRUCT OAMSPRITE
Y DB
X DB
IDX DB
FLAGS DB
.ENDST

; POINT WITH 8.8 FIXED POINT COORDINATES
.STRUCT POINT88
XL DB
XH DB
YL DB
YH DB
.ENDST

.ENUM $FE00
SPRITES INSTANCEOF OAMSPRITE 40
.ENDE

.ENUM $80
; HRAM VARIABLES HERE
DUMMY DB
.ENDE

; BSS SECTION
.ENUM $C000
; 1 = VBLANK INTR OCCURRED
STATICFLAGS DB
; 1 = A
; 2 = B
INPUTFLAGS DB
.ENDE

; DATA SECTION
.ENUM $C800
PLAYERPOS INSTANCEOF POINT88
.ENDE

; Normal Calling Convention:
; HL is a non-volatile register. All other registers are volatile.
; Parameters are passed into C, B, E, D, A, then stack.
; 16-bit values must be aligned on stack or in register pair.
; Otherwise, assign 8-bit parameters in order.

; MEM* RST routines
; These are very common so it's worthwhile to make them RST routines.
; They are generally in 2 flavors. 256-byte block memsets and byte memsets.
; The count must be non-zero or, if you'd like to iterate 256 times, use 0.
; They're defined so you can perform code like the following memset.
;
; LD HL,ADDR
; XOR A
; LD BC,$1234
; RST $8 ; MEMSETLNZ
; RST $0 ; MEMSETHNZ
;
; As you can see, these have a modified calling convention where
; HL is dest, DE is src, BC is counts, and A is the value for memset

; MEMSETHNZ = RST $0
; HL = DEST
; A = DATA
; B = NONZERO # OF 256-BYTE BLOCKS 
.ORG $0
MEMSETHNZ:
LD C,0
MEMSETHNZLOOP:
RST $8
DEC B
JR NZ, MEMSETHNZLOOP
RET

; MEMSETLNZ = RST $8
; HL = DEST
; A = DATA
; C = NONZERO # OF BYTES
.ORG $8
MEMSETLNZ:
LD (HL+),A
DEC C
JR NZ, MEMSETLNZ
RET

; MEMCPYHNZ = RST $10
; HL = DEST
; DE = SRC
; C = NONZERO # OF 256-BYTE BLOCKS
.ORG $10
MEMCPYHNZ:
LD C,0
MEMCPYHNZLOOP:
RST $18
DEC B
JR NZ, MEMCPYHNZLOOP
.ORG $18

; MEMCPYLNZ = RST $10
; HL = DEST
; DE = SRC
; C = NONZERO # OF BYTES
MEMCPYLNZ:
LD A,(DE)
LD (HL+),A
INC DE
DEC C
JR NZ,MEMCPYLNZ
RET

.ORG $40
VBLANKTHUNK:
PUSH BC
PUSH DE
PUSH HL
PUSH AF
JR VBLANKINTR

.ORG $68
VBLANKINTR:
LD HL,STATICFLAGS
SET $0,(HL)
INTRPROLOG:
POP AF
POP HL
POP DE
POP BC
RETI

.ORG $100
JP START
NOP

.GBHEADER

NAME "SPACESHIP"
LICENSEECODENEW "1A"
CARTRIDGETYPE 1
RAMSIZE 0
ROMDMG
COUNTRYCODE 1
DESTINATIONCODE 1
NINTENDOLOGO
VERSION $01

.ENDGB

.ORG $150
START:
; DISABLE INTERRUPTS FOR ANY INITIAL PROCESSING
DI
; MEMSET WRAM TO 0 AND SET SP
LD SP,$D000
LD HL,$C000
LD B,$f
XOR A
RST $0
; COPY DATA SECTION
LD H,$C8
LD C,$4
LD DE,DATASECTION
RST $18
; MEMSET HRAM TO 0
LD HL,$FF80
LD C,$80
RST $8
; RE-ENABLE INTERRUPTS
EI
; Enable interrupts we want (VBLANK)
LD A,1
LDH ($FF),A
; WAIT FOR VBLANK, TURN OFF PPU, THEN CONTROL PPU
; DISABLE PPU FOR NOW
CALL VBLANKINTRWAIT
LD A,0
LDH ($40),A
LD HL,$8000
LD B,$20
RST $0
; ZERO OAM
LD HL,$FE00
LD C,$A0
RST $8
; COPY SPRITE SECTION
LD L,0
LD C,$10
LD DE,SPRITESECTION
RST $18
; LOAD 1 BPP TILE DATA (TILE 0 = EMPTY TILE)
LD HL,$8010
LD DE,BPP1TILEDATA
LD C,$2
CALL BPP1TILECPY
; LOAD INITIAL OBJ PALETTES
LD A,$9C
LDH ($48),A
; RE-ENABLE PPU, ENABLE OBJS
LD A,$82
LDH ($40),A

MAINLOOP:
LDH A,(DUMMY)
INC A
LDH (DUMMY),A
CALL VBLANKINTRWAIT
JR MAINLOOP

; WAIT FOR VBLANK TO PASS
VBLANKINTRWAIT:
LD HL,STATICFLAGS
RES $0,(HL)
VBLANKINTRWAITLOOP:
HALT
BIT $0,(HL)
JR Z, VBLANKINTRWAITLOOP
RET

LD C,$41
LD D,$1
LD E,$3
VBLANKINTRWAITLOOPEXIT:
LDH A,[C]
AND E
CP D
JR Z,VBLANKINTRWAITLOOPEXIT
VBLANKINTRWAITLOOPENTER:
LDH A,[C]
AND E
CP D
JR NZ,VBLANKINTRWAITLOOPEXIT
RET

; Similar to memcpy but with a stride of 2
; to compress certain tiles in ROM to 1bpp
; HL = DST
; DE = SRC
; B = # of tiles in tileset (or 0 for 256 tiles)
BPP1TILECPY:
LD C,8
BPP1TILECPYINNERLOOP:
LD A,(DE)
INC DE
LD (HL+),A
INC HL
DEC C
JR NZ,BPP1TILECPYINNERLOOP
DEC B
JR NZ,BPP1TILECPY
RET

BPP1TILEDATA:
SPACESHIPHALF:
.DB $00,$00,$01,$01,$03,$03,$07,$07,$07,$07,$0F,$0F,$0F,$0F,$0F,$0F

DATASECTION:
.DSTRUCT PLAYERPOSSTART INSTANCEOF POINT88 VALUES
XL: .DB 0
XH: .DB $48
YL: .DB 0
YH: .DB $48
.ENDST

; STATIC SPRITES SECTION
SPRITESECTION:
.DSTRUCT PLAYERTLSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 48
X: .DB 48
IDX: .DB 1
FLAGS: .DB $0
.ENDST
.DSTRUCT PLAYERTRSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 48
X: .DB 56
IDX: .DB 1
FLAGS: .DB $20
.ENDST
.DSTRUCT PLAYERBLSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 56
X: .DB 48
IDX: .DB 2
FLAGS: .DB $0
.ENDST
.DSTRUCT PLAYERBRSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 56
X: .DB 56
IDX: .DB 2
FLAGS: .DB $20
.ENDST
