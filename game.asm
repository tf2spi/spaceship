.MEMORYMAP
SLOTSIZE $4000
DEFAULTSLOT 0
SLOT 0 $0000
SLOT 1 $4000
SLOT 2 $8000 SIZE $2000 "VRAM"
SLOT 3 $C000 SIZE $1000 "WRAM"
SLOT 4 $FF80 SIZE $80 "HRAM"
.ENDME

.ROMBANKMAP
BANKSTOTAL 2
BANKSIZE $4000
BANKS 2
.ENDRO

.STRUCT OAMSPRITE
Y DB
X DB
IDX DB
FLAGS DB
.ENDST

; POINT WITH 8.8 FIXED POINT COORDINATES
.STRUCT POINT88
XL DB
XH DB
YL DB
YH DB
.ENDST

.ENUM $FE00
SPRITES INSTANCEOF OAMSPRITE 40
.ENDE

.ENUM $80
; HRAM VARIABLES HERE
DUMMY DB
.ENDE

; BSS SECTION
.ENUM $C000
; 1 = VBLANK INTR OCCURRED
STATICFLAGS DB
; 01,02,04,08 = A,B,SEL,START
; 10,20,40,80 = R,L,U,D
INPUTFLAGS DB
.ENDE

; DATA SECTION
.ENUM $C800
PLAYERPOS INSTANCEOF POINT88
.ENDE

; MEM* RST routines
; These are very common so it's worthwhile to make them RST routines.
; They are generally in 2 flavors. 256-byte block memsets and byte memsets.
; The count must be non-zero or, if you'd like to iterate 256 times, use 0.
; They're defined so you can perform code like the following memset.
;
; LD HL,ADDR
; XOR A
; LD BC,$1234
; RST $8 ; MEMSETLNZ
; RST $0 ; MEMSETHNZ
;
; As you can see, these have a modified calling convention where
; HL is dest, DE is src, BC is counts, and A is the value for memset

; MEMSETHNZ = RST $0
; HL = DEST
; A = DATA
; B = NONZERO # OF 256-BYTE BLOCKS 
.ORG $0
MEMSETHNZ:
LD C,0
MEMSETHNZLOOP:
RST $8
DEC B
JR NZ, MEMSETHNZLOOP
RET

; MEMSETLNZ = RST $8
; HL = DEST
; A = DATA
; C = NONZERO # OF BYTES
.ORG $8
MEMSETLNZ:
LD (HL+),A
DEC C
JR NZ, MEMSETLNZ
RET

; MEMCPYHNZ = RST $10
; HL = DEST
; DE = SRC
; C = NONZERO # OF 256-BYTE BLOCKS
.ORG $10
MEMCPYHNZ:
LD C,0
MEMCPYHNZLOOP:
RST $18
DEC B
JR NZ, MEMCPYHNZLOOP
.ORG $18

; MEMCPYLNZ = RST $10
; HL = DEST
; DE = SRC
; C = NONZERO # OF BYTES
MEMCPYLNZ:
LD A,(DE)
LD (HL+),A
INC DE
DEC C
JR NZ,MEMCPYLNZ
RET

.ORG $40
VBLANKTHUNK:
PUSH BC
PUSH DE
PUSH HL
PUSH AF
JR VBLANKINTR

.ORG $68
VBLANKINTR:
; SET VBLANK FLAG
LD HL,STATICFLAGS
SET $0,(HL)
; SET INPUT FLAGS
; READ ACTION BUTTONS FIRST
LD HL,INPUTFLAGS
LD A,$20
CALL READINPUT
LD (HL),A
; READ DIRECTIONAL BUTTONS SECOND
LD A,$10
CALL READINPUT
; PUT DIRECTIONS IN HIGH NIBBLE
; LEAVE ACTIONS IN LOW NIBBLE
SWAP A
OR (HL)
LD (HL),A
INTRPROLOG:
POP AF
POP HL
POP DE
POP BC
RETI

; INTERNAL VBLANK ROUTINE TO READ INPUT
; A REGISTER CONTAINS SELECTION TO WRITE TO P1 PORT
; CLOBBERS: C,A
; RETAINS: DE,HL
; RETURNS: INPUTS FROM P1 IN A REGISTER (TOP NIBBLE ZERO)
READINPUT:
LD C,0
LDH (C),A
LD E,4
INPUTLOOP:
LDH A,(C)
DEC E
JR NZ,INPUTLOOP
AND $0F
RET

.ORG $100
JP START
NOP

.GBHEADER

NAME "SPACESHIP"
LICENSEECODENEW "1A"
CARTRIDGETYPE 1
RAMSIZE 0
ROMDMG
COUNTRYCODE 1
DESTINATIONCODE 1
NINTENDOLOGO
VERSION $01

.ENDGB

.ORG $150
START:
; DISABLE INTERRUPTS FOR ANY INITIAL PROCESSING
DI
; MEMSET BSS TO 0 AND SET SP
LD SP,$D000
LD HL,$C000
LD B,$1
XOR A
RST $0
; COPY DATA SECTION
LD H,$C8
LD C,$4
LD DE,DATASECTION
RST $18
; MEMSET HRAM TO 0
LD HL,$FF80
LD C,$80
RST $8
; SET SOUND REGISTERS TO INITIAL VALUES
; START WITH RESETTING APU
LD C,$26
LD A,$00
LDH (C),A
LD A,$80
LDH (C),A
; USE ONLY CHANNEL 1 FOR NOW
LD A,$11
LDH ($25),A
; BLAST AT FULL VOLUME
LD A,$FF
LDH ($24),A
; PLAY A SQUARE WAVE FOR A BIT AT 440HZ (A4)
LD A,$8F
LDH ($11),A
LD A,$F0
LDH ($12),A
LD A,$D7
LDH ($13),A
LD A,$C6
LDH ($14),A
; RE-ENABLE INTERRUPTS
EI
; Enable interrupts we want (VBLANK)
LD A,1
LDH ($FF),A
; WAIT FOR VBLANK, TURN OFF PPU, THEN CONTROL PPU
; DISABLE PPU FOR NOW
CALL VBLANKINTRWAIT
LD A,0
LDH ($40),A
LD HL,$8000
LD B,$20
RST $0
; ZERO OAM
LD HL,$FE00
LD C,$A0
RST $8
; COPY SPRITE SECTION
LD L,0
LD C,$10
LD DE,SPRITESECTION
RST $18
; LOAD 1 BPP TILE DATA (TILE 0 = EMPTY TILE)
LD HL,$8010
LD DE,BPP1TILEDATA
LD C,$2
CALL BPP1TILECPY
; LOAD INITIAL OBJ PALETTES
LD A,$9C
LDH ($48),A
; RE-ENABLE PPU, ENABLE OBJS
LD A,$82
LDH ($40),A

MAINLOOP:
LDH A,(DUMMY)
INC A
LDH (DUMMY),A
CALL VBLANKINTRWAIT
JR MAINLOOP

; WAIT FOR VBLANK TO PASS
VBLANKINTRWAIT:
LD HL,STATICFLAGS
RES $0,(HL)
VBLANKINTRWAITLOOP:
HALT
BIT $0,(HL)
JR Z, VBLANKINTRWAITLOOP
RET

LD C,$41
LD D,$1
LD E,$3
VBLANKINTRWAITLOOPEXIT:
LDH A,[C]
AND E
CP D
JR Z,VBLANKINTRWAITLOOPEXIT
VBLANKINTRWAITLOOPENTER:
LDH A,[C]
AND E
CP D
JR NZ,VBLANKINTRWAITLOOPEXIT
RET

; Similar to memcpy but with a stride of 2
; to compress certain tiles in ROM to 1bpp
; HL = DST
; DE = SRC
; B = # of tiles in tileset (or 0 for 256 tiles)
BPP1TILECPY:
LD C,8
BPP1TILECPYINNERLOOP:
LD A,(DE)
INC DE
LD (HL+),A
INC HL
DEC C
JR NZ,BPP1TILECPYINNERLOOP
DEC B
JR NZ,BPP1TILECPY
RET

BPP1TILEDATA:
SPACESHIPHALF:
.DB $00,$00,$01,$01,$03,$03,$07,$07,$07,$07,$0F,$0F,$0F,$0F,$0F,$0F

DATASECTION:
.DSTRUCT PLAYERPOSSTART INSTANCEOF POINT88 VALUES
XL: .DB 0
XH: .DB $48
YL: .DB 0
YH: .DB $48
.ENDST

; STATIC SPRITES SECTION
SPRITESECTION:
.DSTRUCT PLAYERTLSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 48
X: .DB 48
IDX: .DB 1
FLAGS: .DB $0
.ENDST
.DSTRUCT PLAYERTRSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 48
X: .DB 56
IDX: .DB 1
FLAGS: .DB $20
.ENDST
.DSTRUCT PLAYERBLSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 56
X: .DB 48
IDX: .DB 2
FLAGS: .DB $0
.ENDST
.DSTRUCT PLAYERBRSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 56
X: .DB 56
IDX: .DB 2
FLAGS: .DB $20
.ENDST
