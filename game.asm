.MEMORYMAP
SLOTSIZE $4000
DEFAULTSLOT 0
SLOT 0 $0000
SLOT 1 $4000
SLOT 2 $8000 SIZE $2000 "VRAM"
SLOT 3 $C000 SIZE $1000 "WRAM"
SLOT 4 $FF80 SIZE $80 "HRAM"
.ENDME

.ROMBANKMAP
BANKSTOTAL 2
BANKSIZE $4000
BANKS 2
.ENDRO

.STRUCT OAMSPRITE
Y DB
X DB
IDX DB
FLAGS DB
.ENDST

; POINT WITH 8.8 FIXED POINT COORDINATES
.STRUCT POINT88
XL DB
XH DB
YL DB
YH DB
.ENDST

.ENUM $FE00
SPRITES INSTANCEOF OAMSPRITE 40
.ENDE

.ENUM $80
; INITALIZED HRAM VARIABLES HERE

; HRAM DMA ROUTINE HERE
; WE SAY IT IS DB BUT IT HAS VARIABLE LENGTH
; WHICH MEANS IT MUST BE AT THE END OF THIS SECTION
HRAMDMA DB
.ENDE

; BSS SECTION
.ENUM $C000
; 1 = VBLANK INTR OCCURRED
STATICFLAGS DB
; 01,02,04,08 = A,B,SEL,START
; 10,20,40,80 = R,L,U,D
; PREVINPUTFLAGS SHOULD BE AFTER INPUTFLAGS
; TO DO TRICKS LIKE THIS
;
; LD A,(HL+) ; MOVE INPUT TO PREV
; LD (HL-),A
INPUTFLAGS DB
PREVINPUTFLAGS DB
.ENDE

; DATA SECTION
.ENUM $C800
; OAM SHADOW BUFFER FOR DMA ON VBLANK
OAMSHADOW INSTANCEOF OAMSPRITE 40
PLAYERPOS INSTANCEOF POINT88
; TODO: MAKE A DEDICATED ARRAY FOR BULLETS
BULLETPOS INSTANCEOF POINT88
; TODO: MAKE A DEDICATED ARRAY FOR ENEMIES
.ENDE

; MEM* RST ROUTINES
; THESE ARE VERY COMMON SO MAKE THEM RST ROUTINES
; THERE ARE 256-BYTE BLOCK AND BYTE MEM ROUTINES
; COUNTS ARE NON-ZERO AND IF THE COUNT IS 256, USE 0 INSTEAD
; THEY'RE DESIGNED TO PERFORM THE FOLLOWING MEM ROUTINES
;
; LD HL,ADDR
; XOR A
; LD BC,$1234
; RST $8 ; MEMSETLNZ
; RST $0 ; MEMSETHNZ
;
; NOTE THAT THE BYTE ROUTINES DO NOT TOUCH THE B REGISTER,
; SO YOU DO NOT HAVE TO PUSH THAT REGISTER ONTO THE STACK
; BEFORE CALLING THESE RST FUNCTIONS. SOME CODE RELIES ON THIS.

; MEMSETHNZ = RST $0
; HL = DEST
; A = DATA
; B = NONZERO # OF 256-BYTE BLOCKS 
.ORG $0
MEMSETHNZ:
LD C,0
MEMSETHNZLOOP:
RST $8
DEC B
JR NZ, MEMSETHNZLOOP
RET

; MEMSETLNZ = RST $8
; HL = DEST
; A = DATA
; C = NONZERO # OF BYTES
.ORG $8
MEMSETLNZ:
LD (HL+),A
DEC C
JR NZ, MEMSETLNZ
RET

; MEMCPYHNZ = RST $10
; HL = DEST
; DE = SRC
; C = NONZERO # OF 256-BYTE BLOCKS
.ORG $10
MEMCPYHNZ:
LD C,0
MEMCPYHNZLOOP:
RST $18
DEC B
JR NZ, MEMCPYHNZLOOP
.ORG $18

; MEMCPYLNZ = RST $18
; HL = DEST
; DE = SRC
; C = NONZERO # OF BYTES
MEMCPYLNZ:
LD A,(DE)
LD (HL+),A
INC DE
DEC C
JR NZ,MEMCPYLNZ
RET

; ADD16 = RST $20
; HL = ADDRESS OF 16-BIT LHS OP AND RESULT
; DE = 16-BIT RHS OP
; ALL REGISTERS PRESERVED EXCEPT AF
.ORG $20
ADD16:
LD A,E
ADD (HL)
LD (HL+),A
LD A,D
ADC (HL)
LD (HL-),A
RET

; SUB16 = RST $28
; HL = ADDRESS OF 16-BIT LHS OP AND RESULT
; DE = 16-BIT RHS OP
; ALL REGISTERS PRESERVED EXCEPT AF
.ORG $28
SUB16:
LD A,(HL)
SUB E
LD (HL+),A
LD A,(HL)
SBC D
LD (HL-),A
RET

.ORG $30
RET

.ORG $38
RET

.ORG $40
VBLANKTHUNK:
PUSH BC
PUSH DE
PUSH HL
PUSH AF
JR VBLANKINTR

.ORG $68
VBLANKINTR:
; SET VBLANK FLAG
LD HL,STATICFLAGS
SET $0,(HL)
; MOVE INPUTFLAGS TO PREVINPUTFLAGS
LD HL,INPUTFLAGS
LD A,(HL+)
LD (HL-),A
LD A,$10
; SET INPUT FLAGS
; READ ACTION BUTTONS FIRST
CALL READINPUT
LD (HL),A
; READ DIRECTIONAL BUTTONS SECOND
LD A,$20
CALL READINPUT
; PUT DIRECTIONS IN HIGH NIBBLE
; LEAVE ACTIONS IN LOW NIBBLE
SWAP A
OR (HL)
LD (HL),A
CALL $FF00+HRAMDMA
INTRPROLOG:
POP AF
POP HL
POP DE
POP BC
RETI

; INTERNAL VBLANK ROUTINE TO READ INPUT
; A REGISTER CONTAINS SELECTION TO WRITE TO P1 PORT
; CLOBBERS: C,A
; RETAINS: DE,HL
; RETURNS: INPUTS FROM P1 IN A REGISTER (TOP NIBBLE ZERO)
READINPUT:
LD C,0
LDH (C),A
LD E,4
INPUTLOOP:
LDH A,(C)
DEC E
JR NZ,INPUTLOOP
AND $0F
RET

.ORG $100
JP START
NOP

.GBHEADER

NAME "SPACESHIP"
LICENSEECODENEW "1A"
CARTRIDGETYPE 1
RAMSIZE 0
ROMDMG
COUNTRYCODE 1
DESTINATIONCODE 1
NINTENDOLOGO
VERSION $01

.ENDGB

.ORG $150
START:
; DISABLE INTERRUPTS FOR ANY INITIAL PROCESSING
DI
; MEMSET BSS TO 0 AND SET SP
LD SP,$D000
LD HL,$C000
LD B,$1
XOR A
RST $0
; MEMSET HRAM TO 0
LD HL,$FF80
LD C,$80
RST $8
; COPY SPRITE SECTION
; ZERO OUT THE REST OF THE BYTES OF OAM
LD HL,OAMSHADOW
LD C,$10
LD DE,SPRITESECTION
RST $18
LD C,$90
XOR A
RST $8
; COPY DATA SECTION
LD C,$4
RST $18
; COPY HRAM SECTION
LD HL,$FF80
LD C,HRAMSECTIONEND-HRAMSECTION
RST $18
; SET MASTER SOUND REGISTERS TO INITIAL VALUES
; RESET APU
LD C,$24
XOR A
LDH (C),A
LD A,$80
LDH (C),A
; BLAST AT FULL VOLUME
LD C,$24
LD A,$FF
LDH (C),A
; MIX ONLY CHANNEL 1 FOR NOW
INC C
LD A,$11
LDH (C),A
; RE-ENABLE INTERRUPTS
EI
; ENABLE INTERRUPTS WE WANT (VBLANK)
LD A,1
LDH ($FF),A
; WAIT FOR VBLANK, TURN OFF PPU, THEN CONTROL PPU
; DISABLE PPU FOR NOW
CALL VBLANKINTRWAIT
LD A,0
LDH ($40),A
LD HL,$8000
LD B,$20
RST $0
; ZERO OAM
LD HL,$FE00
LD C,$A0
RST $8
; LOAD 1 BPP TILE DATA (TILE 0 = EMPTY TILE)
LD HL,$8010
LD DE,BPP1TILEDATA
LD C,$3
CALL BPP1TILECPY
; LOAD INITIAL OBJ PALETTES
LD A,$9C
LDH ($48),A
; RE-ENABLE PPU, ENABLE OBJS
LD A,$82
LDH ($40),A

MAINLOOP:
CALL VBLANKINTRWAIT
; TODO: IMPLEMENT PAUSING
; CALL THESE WHEN THE GAME IS NOT PAUSED
CALL UPDATEFROMINPUT
CALL UPDATEENTITIES
; ALWAYS CALL THIS REGARDLESS IF THE GAME IS PAUSED
CALL UPDATEOAM
JR MAINLOOP

UPDATEENTITIES:
LD DE,$0327
LD HL,BULLETPOS+2
JP SUB16

; UPDATE BASED ON INPUT
UPDATEFROMINPUT:
LD DE, $0102
LD HL, PLAYERPOS
LD A,(INPUTFLAGS)
LD B,A
; MOVE X POSITION
MOVESHIPLEFT:
BIT $5,B
JR NZ,MOVESHIPRIGHT
RST $28
MOVESHIPRIGHT:
BIT $4,B
JR NZ,MOVESHIPDOWN
RST $20
; INC HL BY 2 TO MOVE Y POSITION
MOVESHIPDOWN:
INC HL
INC HL
BIT $7,B
JR NZ,MOVESHIPUP
RST $20
MOVESHIPUP:
BIT $6,B
JR NZ,MOVESHIPDONE
RST $28
; SHOOT BULLETS!
; WE WANT TO DO THIS ON A BUTTON PRESS
; SO COMPUTE NEW FLAGS USING PREVINPUTFLAGS
MOVESHIPDONE:
LD A,(PREVINPUTFLAGS)
CPL
OR B
LD B,A
BIT $1,B
RET NZ
; LOAD MODIFIED XY INTO DE TO USE FOR SPAWN BULLET
INC HL
LD A,(HL-)
SUB A,$2
LD E,A
DEC HL
LD A,(HL-)
ADD A,$4
LD D,A
; OTHER ENTITIES CAN USE THIS TOO FOR
; SPAWNING BULLETS, NOT JUST THE SHIP
; DE = XY POSITION
; ALL REGISTERS CLOBBERED EXCEPT B REGISTER
SPAWNBULLET:
; TODO: ACTUALLY MANAGE OAM SO THAT BULLETS SPAWN AND DESPAWN AS WELL
LD HL,BULLETPOS
XOR A
LD (HL+),A
LD (HL),D
INC HL
LD (HL+),A
LD (HL),E
INC HL
; OAM FLAGS = 0, OAM TILE = 3
LD HL,OAMSHADOW+19
LD (HL-),A
LD A,$03
LD (HL),A
; PLAY BULLET SOUND IN NR1 REGISTERS
PLAYBULLETSOUND:
LD HL,$FF10
LD DE,BULLETSOUND
LD C,$5
JP MEMCPYLNZ

UPDATEOAM:
; UPDATE OTHER ENTITIES HERE EVENTUALLY
; EVENTUALLY, THE SHIP SHOUD BE AN ENTITY JUST LIKE
; ANYTHING ELSE, BUT HARDCODED AT INDEX 0
; REFLECT UPDATES TO BULLETS IN OAM
UPDATEBULLETSOAM:
LD HL,BULLETPOS+1
LD DE,OAMSHADOW+17
LD A,(HL+)
LD (DE),A
INC HL
DEC DE
LD A,(HL+)
LD (DE),A

; REFLECT UPDATES TO SHIP IN OAM
; WHOSE SPRITES ARE AT SPRITE 0
UPDATESHIPOAM:
LD HL,PLAYERPOS+3
LD E,(HL)
DEC HL
DEC HL
LD D,(HL)
LD HL,OAMSHADOW
LD BC,$0202
CALL UPDATEOAMPOS
RET


BULLETSOUND:
.DB $00, $8F, $F0, $6E, $C3

; HL = OAM SPRITES LOCATION
; DE = XY POSITION
; BC = WH DIMENSIONS
UPDATEOAMPOS:
UPDATEOAMYLOOP:
LD A,D
PUSH BC
UPDATEOAMXLOOP:
LD (HL),E
INC HL
LD (HL+),A
INC HL
INC HL
ADD $8
DEC B
JR NZ,UPDATEOAMXLOOP
POP BC
LD A,E
ADD $8
LD E,A
DEC C
JR NZ,UPDATEOAMYLOOP
RET

; WAIT FOR VBLANK TO PASS
VBLANKINTRWAIT:
LD HL,STATICFLAGS
RES $0,(HL)
VBLANKINTRWAITLOOP:
HALT
BIT $0,(HL)
JR Z, VBLANKINTRWAITLOOP
RET

LD C,$41
LD D,$1
LD E,$3
VBLANKINTRWAITLOOPEXIT:
LDH A,[C]
AND E
CP D
JR Z,VBLANKINTRWAITLOOPEXIT
VBLANKINTRWAITLOOPENTER:
LDH A,[C]
AND E
CP D
JR NZ,VBLANKINTRWAITLOOPEXIT
RET

; SIMILAR TO MEMCPY BUT WITH A STRIDE OF 2
; TO COMPRESS CERTAIN TILES IN ROM TO 1BPP
; HL = DST
; DE = SRC
; B = # OF TILES IN TILESET (OR 0 FOR 256 TILES)
BPP1TILECPY:
LD C,8
BPP1TILECPYINNERLOOP:
LD A,(DE)
INC DE
LD (HL+),A
INC HL
DEC C
JR NZ,BPP1TILECPYINNERLOOP
DEC B
JR NZ,BPP1TILECPY
RET

BPP1TILEDATA:
SPACESHIPHALFTILES:
.DB $00,$00,$01,$01,$03,$03,$07,$07,$07,$07,$0F,$0F,$0F,$0F,$0F,$0F
BULLETTILES:
.DB $00,$00,$00,$18,$18,$00,$00,$00

; INITIALIZED DATA SECTIONS
; COPY THESE IN ORDER TO OPTIMIZE MEMCPY ROUTINES
SPRITESECTION:
.DSTRUCT PLAYERTLSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 48
X: .DB 48
IDX: .DB 1
FLAGS: .DB $0
.ENDST
.DSTRUCT PLAYERTRSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 48
X: .DB 56
IDX: .DB 1
FLAGS: .DB $20
.ENDST
.DSTRUCT PLAYERBLSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 56
X: .DB 48
IDX: .DB 2
FLAGS: .DB $0
.ENDST
.DSTRUCT PLAYERBRSPRITE INSTANCEOF OAMSPRITE VALUES
Y: .DB 56
X: .DB 56
IDX: .DB 2
FLAGS: .DB $20
.ENDST

DATASECTION:
.DSTRUCT PLAYERPOSSTART INSTANCEOF POINT88 VALUES
XL: .DB 0
XH: .DB $48
YL: .DB 0
YH: .DB $48
.ENDST

HRAMSECTION:
; THIS FUNCTION SHOULD ALWAYS BE AT THE END OF THE HRAM SECTION
; BECAUSE IT HAS VARIABLE LENGTH WHICH COULD SHIFT VARIABLES
HRAMROUTINEDMA:
LD A,$C8 ; OAMSHADOW
LDH ($46),A
LD A,$40
DMAWAIT:
DEC A
JR NZ,DMAWAIT
RET
HRAMSECTIONEND:
; HRAM < 256 BYTES, SO YOU CAN INDEED DO THIS
; LD C, (HRAMSECTIONEND - HRAMSECTION)



